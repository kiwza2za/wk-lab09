# ปฏิบัติการที่ 9: สร้าง App ง่ายๆ ด้วย Async/Await

## ส่วนที่ 1: การทำความเข้าใจโค้ด

**1.1 ความแตกต่างระหว่าง `duration` และ `timeLeft`**

- `duration`: คือเวลาตั้งต้น (30 นาที) เอาไว้ใช้ตอนจะ Reset หรือดูว่า Task นี้ยาวกี่นาที
- `timeLeft`: คือเวลาที่เหลืออยู่จริง ณ ตอนนั้น ซึ่งจะลดลงเรื่อยๆ
- _ถ้าไม่แยก:_ เราจะไม่รู้ว่า Task นี้เดิมทีตั้งเวลาไว้กี่นาที ถ้าจะเริ่มใหม่ก็ทำไม่ได้

**1.2 ความสำคัญของ `formatTime()`**

- แปลงตัวเลขวินาที (เช่น 90) ให้เป็นรูปแบบที่มนุษย์อ่านง่าย (01:30)
- _ถ้าไม่มี:_ user จะเห็นเลข 1800 วินาที ซึ่งดูยากมาก

**1.3 `setInterval()` vs `setTimeout()`**

- `setInterval`: ทำซ้ำไปเรื่อยๆ ตามเวลาที่กำหนด (Loop) จนกว่าจะสั่งหยุด
- `setTimeout`: ทำแค่ครั้งเดียว เมื่อครบเวลาที่กำหนด (Delay)

---

## ส่วนที่ 2: ฟังก์ชันการทำงาน

**2.1 ขั้นตอนเมื่อคลิกปุ่ม "▶️ เริ่ม"**

1.  ฟังก์ชัน `toggleTimer(id)` ถูกเรียก
2.  หา object task ที่ตรงกับ id
3.  เปลี่ยนสถานะ `isRunning = true`
4.  สั่ง `setInterval` เพื่อลด `timeLeft` ทุก 1 วินาที
5.  เรียก `renderTasks()` เพื่อเปลี่ยนปุ่มเป็น "หยุด"

**2.2 ทำไมต้อง `clearInterval()` ก่อน `isRunning = false`**

- ต้องหยุดกลไกการนับเวลา (System process) ก่อน แล้วค่อยอัปเดตสถานะข้อมูล เพื่อไม่ให้ Timer ทำงานซ้อนกันหรือทำงานค้างอยู่เบื้องหลัง

**2.3 ถ้าไม่มี `clearInterval()` ตอนหมดเวลา**

- เวลาจะติดลบไปเรื่อยๆ (-1, -2...) และเสียง Alarm อาจจะดังไม่หยุด หรือ Logic การจบงานจะไม่ทำงาน

---

## ส่วนที่ 3: DOM และ UI

**3.1 การแยกฟังก์ชัน `renderTasks()`**

- แยกได้เป็น: `createTaskHTML(task)` สำหรับสร้างโค้ด HTML ของแต่ละก้อน และ `updateTaskList()` สำหรับเอา HTML ไปใส่ใน Container

**3.2 วิธีอัปเดต UI**

- ตอนนี้ใช้: ลบแล้วสร้างใหม่หมด (`innerHTML`)
- วิธีอื่นที่ดีกว่า: เลือก Element ที่เจาะจง (เช่น `span` ของเวลา) แล้วแก้แค่ `textContent` โดยไม่ต้อง Render ใหม่ทั้งลิสต์

**3.3 ความสำคัญของ "keypress"**

- ทำให้กดปุ่ม Enter ที่คีย์บอร์ดเพื่อเพิ่ม Task ได้เลย
- _ถ้าลบออก:_ ต้องเลื่อนเมาส์ไปกดปุ่ม "เพิ่ม" เท่านั้น ไม่สะดวก

---

## ส่วนที่ 4: Web Audio API

**4.1 อธิบายการตั้งค่าเสียง**

- `frequency = 800`: ความถี่เสียง (โทนเสียงสูง/แหลม)
- `type = "sine"`: รูปแบบคลื่นเสียง (Sine wave เสียงจะนุ่มๆ ไม่แตก)
- `gain = 0.3`: ความดังเสียง (30%)

**4.2 ทำไม Alarm แค่ 0.5 วิ**

- เพื่อให้แค่ "แจ้งเตือน" ว่าเสร็จแล้ว ไม่ให้รบกวนจนน่ารำคาญ
- _ถ้า 2 วิ:_ ผู้ใช้อาจจะตกใจหรือรำคาญ เพราะเสียง beep ยาวเกินไป

---

## ส่วนที่ 5: Array Methods

**5.1 การใช้ `filter()` ใน `deleteTask`**

- ใช้สร้าง Array ใหม่ที่ **ไม่มี** ID ที่เราเลือก (คัดตัวที่จะลบออกไป)
- _วิธีอื่น:_ ใช้ `splice()` แต่ต้องหา index ก่อน หรือใช้ `for loop` สร้าง array ใหม่เอง

**5.2 การใช้ `map()` ใน `renderTasks`**

- ใช้แปลงข้อมูล (Object) ให้กลายเป็น HTML String
- _ใช้ `forEach` ได้ไหม:_ ไม่ดี เพราะ `forEach` ไม่ return ค่ากลับมา ต้องสร้างตัวแปรมารอรับค่าเพิ่มเอง ทำให้โค้ดยาวขึ้น

---

## ส่วนที่ 6: ข้อบกพร่องและการแก้ไข

**6.1 ถ้ากดเริ่ม 2 Task พร้อมกัน**

- ทำงานได้ปกติ เพราะแยก `intervalId` เก็บไว้ใน object ของใครของมัน ไม่ตีกัน

**6.2 รีเฟรชหน้าแล้ว Task หาย**

- เพราะข้อมูลเก็บในตัวแปร (RAM) พอรีเฟรชก็เคลียร์ทิ้ง
- _แก้โดย:_ เก็บลง `localStorage` หรือ Database

**6.3 วิธีทดสอบ Timer 30 นาที ให้เร็วขึ้น**

- แก้ code ตรง `duration` จาก `30 * 60` เป็น `5` (5 วินาที) เพื่อทดสอบ function จบงาน

---

## ส่วนที่ 7: Enhancement

**7.1 ฟังก์ชัน Reset Timer**

```javascript
function resetTimer(id) {
  const task = tasks.find((t) => t.id === id);
  clearInterval(task.intervalId);
  task.isRunning = false;
  task.timeLeft = task.duration; // คืนค่าเดิม
  renderTasks();
}
```

7.2 วิธีเก็บ LocalStorage

ใช้ localStorage.setItem('tasks', JSON.stringify(tasks)) ทุกครั้งที่มีการ เพิ่ม/ลบ/แก้ data

และตอนเปิดเว็บใช้ JSON.parse() ดึงกลับมา

7.3 ถ้าจะให้กำหนดเวลาเอง

แก้ HTML: เพิ่ม <input type="number" id="durationInput">

แก้ JS: ตอน addTask ให้อ่านค่าจาก input นี้มาคำนวณเป็นวินาที แทนที่จะใช้ค่าตายตัว 30 นาที

ส่วนที่ 8: Concepts เชิงลึก
8.1 renderTasks เรียกซ้ำบ่อยไปไหม

บ่อยไป (ทุก 1 วิ) ทำให้กินทรัพยากร browser ถ้า task เยอะๆ

วิธีแก้ (DRY/Performance): อัปเดตเฉพาะตัวเลขเวลาของ Task นั้นๆ ผ่าน DOM ID ไม่ต้อง re-render ทั้งก้อน

8.2 ใช้ requestAnimationFrame แทน setInterval

ดีกว่าในแง่ความลื่นไหลของ UI และหยุดทำงานเมื่อพับหน้าจอ (ประหยัดแบต) แต่เขียนยากกว่านิดหน่อยสำหรับการนับเวลาแบบวินาทีเป๊ะๆ

8.3 Memory Leak ใน setInterval

มีโอกาสเกิดขึ้นถ้าเรา deleteTask (ลบ task ออกจาก array/หน้าจอ) แต่ลืมสั่ง clearInterval ของ task นั้น ตัว timer จะยังทำงานอยู่ใน background กินแรมเครื่องไปเรื่อยๆ

# ปฏิบัติการที่ 9: Pomodoro Timer App

## ส่วนที่ 1: ความเข้าใจเทคนิค Pomodoro

**1.1 เทคนิค Pomodoro คืออะไร**

- คือเทคนิคบริหารเวลาโดยแบ่งการทำงานเป็นช่วงๆ (ปกติ 25 นาที) เรียกว่า 1 Pomodoro แล้วพักสั้นๆ (5 นาที) เพื่อให้สมองตื่นตัวและโฟกัสได้ดีขึ้น

**1.2 การปรับเวลา Work/Break**

- ในโค้ด: แก้ไขค่าใน `state` เริ่มต้น (`timeLeft`, `workDuration`)
- หรือแก้ไขผ่าน UI: กรอกเลขใน Input (`workTimeInput`, `breakTimeInput`) ซึ่งมี Event Listener คอยดักจับค่าการเปลี่ยนแปลงอยู่

**1.3 ทำไมต้องมี Long Break**

- เพื่อให้สมองได้พักผ่อนอย่างเต็มที่หลังจากโฟกัสต่อเนื่องมานาน (4 รอบ) ช่วยลดความเหนื่อยล้า (Burnout)

---

## ส่วนที่ 2: การจัดโครงสร้าง State

**2.1 State ที่เก็บในปัจจุบัน**

- `timeLeft` (เวลาที่เหลือ), `isRunning` (สถานะจับเวลา), `isWorkPhase` (ทำงานหรือพัก), `currentSession` (รอบปัจจุบัน), `completedSessions` (จำนวนรอบที่ทำเสร็จ)

**2.2 ทำไมต้องมี `currentSession`**

- เพราะระบบต้องนับรอบเพื่อตัดสินใจว่า "เมื่อไหร่ควรจะพักยาว (Long Break)" (เงื่อนไข `currentSession % 4 === 0`) แค่รู้ว่าเป็น Work/Break ไม่เพียงพอ

**2.3 การอัปเดต Pomodoro Count**

- แก้ไขในส่วน `if (state.timeLeft <= 0)` เมื่อจบ Work Phase โค้ดมีการทำ `state.completedSessions++` อยู่แล้ว แต่ต้องเรียก `updateDisplay()` เพื่อให้ตัวเลขหน้าจอเปลี่ยน

---

## ส่วนที่ 3: Timer Logic

**3.1 การทำงานของ `setInterval()`**

- ทุกๆ 1,000 มิลลิวินาที (1 วินาที) โค้ดภายในปีกกาจะทำงาน คือ ลดค่า `timeLeft` ลง 1 และตรวจสอบว่าเวลาหมดหรือยัง

**3.2 ความสำคัญของ `state.intervalId`**

- เก็บ "รหัส" ของตัวจับเวลาเอาไว้ เพื่อใช้ในคำสั่ง `clearInterval(state.intervalId)` เพื่อหยุดเวลา ถ้าไม่มีตัวแปรนี้ เราจะสั่งหยุด Loop ไม่ได้เลย

**3.3 ถ้าคลิก "เริ่ม" 2 ครั้ง**

- ในโค้ดเขียนดักไว้แล้ว: คลิกครั้งแรก `isRunning` เป็น false -> เริ่มจับเวลา, คลิกครั้งที่สอง `isRunning` เป็น true -> สั่งหยุด (Pause)
- _ผลลัพธ์:_ คือการ เริ่ม และ หยุด สลับกัน

---

## ส่วนที่ 4: DOM & UI

**4.1 หน้าที่ของ `updateDisplay()`**

- ทำหน้าที่ "วาดหน้าจอใหม่" ตามค่า State ปัจจุบัน (เวลา, หลอด Progress, ปุ่ม, ข้อความ Phase)
- เรียกใช้ตอน: เริ่มโปรแกรม, กดปุ่มเริ่ม/รีเซ็ต, เปลี่ยนค่า Input, และทุกวินาทีที่เวลาเดิน

**4.2 `padStart(2, "0")` ใน `formatTime()`**

- เพื่อเติมเลข 0 ข้างหน้าให้ครบ 2 หลักเสมอ
- _ถ้าไม่มี:_ เวลา 5 นาที 5 วินาที จะแสดงเป็น `5:5` แทนที่จะเป็น `05:05` ซึ่งดูยากและไม่สวยงาม

**4.3 สูตรคำนวณ Progress Bar**

- `((เวลาทั้งหมด - เวลาที่เหลือ) / เวลาทั้งหมด) * 100`
- ตัวอย่าง: เวลาทั้งหมด 60 วิ, เหลือ 30 วิ -> ((60-30)/60)\*100 = 50%

---

## ส่วนที่ 5: Events & Controls

**5.1 ปุ่มควบคุม**

- **Start/Pause:** เรียก `startTimer()` (ทำหน้าที่สลับไปมา)
- **Reset:** เรียก `resetTimer()` (คืนค่าเริ่มต้น)

**5.2 ทำไม Pause ต้อง `clearInterval()`**

- เพื่อหยุดการทำงานของ CPU ที่รัน Loop นับเวลาอยู่ ถ้าไม่ทำ ตัวเลขนับถอยหลังจะยังทำงานต่อใน Background แม้เราจะกดหยุดแล้ว

**5.3 การตั้งค่า Reset**

- `isRunning` = false
- `isWorkPhase` = true
- `currentSession` = 1
- `timeLeft` = `workDuration` (กลับไปเริ่มต้นใหม่หมด)

---

## ส่วนที่ 6: Notifications & Sound

**6.1 เทคนิคสร้างเสียง**

- ใช้ **Web Audio API** (`AudioContext`, `Oscillator`) เป็นการสังเคราะห์เสียงด้วย Code ไม่ได้ใช้ไฟล์ mp3

**6.2 ความแตกต่างของเสียง Notification**

- **Work Phase:** ใช้ความถี่ 800Hz (เสียงต่ำกว่า)
- **Break Phase:** ใช้ความถี่ 1200Hz (เสียงสูงกว่า) เพื่อให้ผู้ใช้รู้ว่าจบช่วงไหนโดยไม่ต้องมองจอ

**6.3 เพิ่ม Browser Notification**

- ต้องขอสิทธิ์ `Notification.requestPermission()` ก่อน
- ในส่วนที่เวลาหมด ให้เพิ่ม `new Notification("ข้อความเตือน")`

---

## ส่วนที่ 7: Progress Tracking & Stats

**7.1 ข้อมูล Stats ที่ติดตาม**

- `state.completedSessions` (จำนวน Pomodoro ที่จบ)
- เวลารวม (Total Time) คำนวณจาก `completedSessions * workDuration`

**7.2 ตำแหน่งอัปเดต Stats**

- ภายในฟังก์ชัน `updateDisplay()` จะดีที่สุด เพราะถูกเรียกตลอดเวลา หรือเรียกเฉพาะตอนจบ Phase ใน `setInterval` ก็ได้

**7.3 บันทึกลง LocalStorage**

- ใช้ `localStorage.setItem('pomoState', JSON.stringify(state))` ทุกครั้งที่จบ Phase

---

## ส่วนที่ 8: Bug Detection

**8.1 เปิด DevTools**

- Timer ยังเดินต่อปกติ แต่อาจมีหน่วงบ้างเล็กน้อยขึ้นอยู่กับประสิทธิภาพเครื่อง

**8.2 Memory Leak**

- ถ้ากด Start รัวๆ โดยไม่ได้เช็ค `isRunning` หรือไม่ได้ `clearInterval` ของเก่า จะเกิด Timer ซ้อนกันหลายตัว ทำให้เวลานับเร็วผิดปกติ (ในโค้ดนี้จัดการไว้แล้ว)

**8.3 Mobile Lock Screen (สำคัญ)**

- **ปัญหา:** Browser บนมือถือจะหยุดการทำงานของ JavaScript (`setInterval`) เมื่อปิดหน้าจอเพื่อประหยัดแบต ทำให้เวลาเดินไม่ตรง (ช้ากว่าความเป็นจริง)
- **วิธีแก้:** แทนที่จะนับลบทีละ 1, ให้บันทึก `endTime` (เวลาจบ) ไว้ แล้วคำนวณหา "เวลาที่เหลือ" โดยเอา `endTime - Date.now()`

---

## ส่วนที่ 9: Architecture & Code Quality

**9.1 การแยก Class**

- สร้าง `class PomodoroTimer { constructor() { ... } start() { ... } }` เพื่อห่อหุ้ม Logic ไม่ให้ปนกับ UI Code

**9.2 การใช้ Object**

- ปัจจุบันใช้ `state` object อยู่แล้ว ซึ่งดีมาก ทำให้จัดการตัวแปรได้ง่าย ไม่กระจัดกระจาย

**9.3 Utility Functions**

- `formatTime(seconds)`: ใช้แปลงเวลา
- `playNotification()`: ใช้เล่นเสียง
- สามารถแยกไปไว้ไฟล์ `utils.js` ได้เพื่อให้โค้ดหลักสะอาดขึ้น

---

## ส่วนที่ 10: Enhancements

**10.1 Dark Mode**

- **CSS:** ใช้ CSS Variables (`:root { --bg-color: white; }`) และสร้าง class `.dark-mode { --bg-color: #333; }`
- **JS:** สั่ง `document.body.classList.toggle('dark-mode')`

**10.2 Session History**

- สร้าง Array `history = []`
- ทุกครั้งที่จบ Phase ให้ `push` object `{ type: 'WORK', timestamp: new Date() }` เข้าไป

**10.3 Keyboard Shortcuts**

- ใช้ `document.addEventListener('keydown', (e) => ...)`
- เช็ค `e.code === 'Space'` ให้เรียก `startTimer()`
- เช็ค `e.key === 'r'` ให้เรียก `resetTimer()`
