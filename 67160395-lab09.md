# ปฏิบัติการที่ 9: สร้าง App ง่ายๆ ด้วย Async/Await

## ส่วนที่ 1: การทำความเข้าใจโค้ด

**1.1 ความแตกต่างระหว่าง `duration` และ `timeLeft`**

- `duration`: คือเวลาตั้งต้น (30 นาที) เอาไว้ใช้ตอนจะ Reset หรือดูว่า Task นี้ยาวกี่นาที
- `timeLeft`: คือเวลาที่เหลืออยู่จริง ณ ตอนนั้น ซึ่งจะลดลงเรื่อยๆ
- _ถ้าไม่แยก:_ เราจะไม่รู้ว่า Task นี้เดิมทีตั้งเวลาไว้กี่นาที ถ้าจะเริ่มใหม่ก็ทำไม่ได้

**1.2 ความสำคัญของ `formatTime()`**

- แปลงตัวเลขวินาที (เช่น 90) ให้เป็นรูปแบบที่มนุษย์อ่านง่าย (01:30)
- _ถ้าไม่มี:_ user จะเห็นเลข 1800 วินาที ซึ่งดูยากมาก

**1.3 `setInterval()` vs `setTimeout()`**

- `setInterval`: ทำซ้ำไปเรื่อยๆ ตามเวลาที่กำหนด (Loop) จนกว่าจะสั่งหยุด
- `setTimeout`: ทำแค่ครั้งเดียว เมื่อครบเวลาที่กำหนด (Delay)

---

## ส่วนที่ 2: ฟังก์ชันการทำงาน

**2.1 ขั้นตอนเมื่อคลิกปุ่ม "▶️ เริ่ม"**

1.  ฟังก์ชัน `toggleTimer(id)` ถูกเรียก
2.  หา object task ที่ตรงกับ id
3.  เปลี่ยนสถานะ `isRunning = true`
4.  สั่ง `setInterval` เพื่อลด `timeLeft` ทุก 1 วินาที
5.  เรียก `renderTasks()` เพื่อเปลี่ยนปุ่มเป็น "หยุด"

**2.2 ทำไมต้อง `clearInterval()` ก่อน `isRunning = false`**

- ต้องหยุดกลไกการนับเวลา (System process) ก่อน แล้วค่อยอัปเดตสถานะข้อมูล เพื่อไม่ให้ Timer ทำงานซ้อนกันหรือทำงานค้างอยู่เบื้องหลัง

**2.3 ถ้าไม่มี `clearInterval()` ตอนหมดเวลา**

- เวลาจะติดลบไปเรื่อยๆ (-1, -2...) และเสียง Alarm อาจจะดังไม่หยุด หรือ Logic การจบงานจะไม่ทำงาน

---

## ส่วนที่ 3: DOM และ UI

**3.1 การแยกฟังก์ชัน `renderTasks()`**

- แยกได้เป็น: `createTaskHTML(task)` สำหรับสร้างโค้ด HTML ของแต่ละก้อน และ `updateTaskList()` สำหรับเอา HTML ไปใส่ใน Container

**3.2 วิธีอัปเดต UI**

- ตอนนี้ใช้: ลบแล้วสร้างใหม่หมด (`innerHTML`)
- วิธีอื่นที่ดีกว่า: เลือก Element ที่เจาะจง (เช่น `span` ของเวลา) แล้วแก้แค่ `textContent` โดยไม่ต้อง Render ใหม่ทั้งลิสต์

**3.3 ความสำคัญของ "keypress"**

- ทำให้กดปุ่ม Enter ที่คีย์บอร์ดเพื่อเพิ่ม Task ได้เลย
- _ถ้าลบออก:_ ต้องเลื่อนเมาส์ไปกดปุ่ม "เพิ่ม" เท่านั้น ไม่สะดวก

---

## ส่วนที่ 4: Web Audio API

**4.1 อธิบายการตั้งค่าเสียง**

- `frequency = 800`: ความถี่เสียง (โทนเสียงสูง/แหลม)
- `type = "sine"`: รูปแบบคลื่นเสียง (Sine wave เสียงจะนุ่มๆ ไม่แตก)
- `gain = 0.3`: ความดังเสียง (30%)

**4.2 ทำไม Alarm แค่ 0.5 วิ**

- เพื่อให้แค่ "แจ้งเตือน" ว่าเสร็จแล้ว ไม่ให้รบกวนจนน่ารำคาญ
- _ถ้า 2 วิ:_ ผู้ใช้อาจจะตกใจหรือรำคาญ เพราะเสียง beep ยาวเกินไป

---

## ส่วนที่ 5: Array Methods

**5.1 การใช้ `filter()` ใน `deleteTask`**

- ใช้สร้าง Array ใหม่ที่ **ไม่มี** ID ที่เราเลือก (คัดตัวที่จะลบออกไป)
- _วิธีอื่น:_ ใช้ `splice()` แต่ต้องหา index ก่อน หรือใช้ `for loop` สร้าง array ใหม่เอง

**5.2 การใช้ `map()` ใน `renderTasks`**

- ใช้แปลงข้อมูล (Object) ให้กลายเป็น HTML String
- _ใช้ `forEach` ได้ไหม:_ ไม่ดี เพราะ `forEach` ไม่ return ค่ากลับมา ต้องสร้างตัวแปรมารอรับค่าเพิ่มเอง ทำให้โค้ดยาวขึ้น

---

## ส่วนที่ 6: ข้อบกพร่องและการแก้ไข

**6.1 ถ้ากดเริ่ม 2 Task พร้อมกัน**

- ทำงานได้ปกติ เพราะแยก `intervalId` เก็บไว้ใน object ของใครของมัน ไม่ตีกัน

**6.2 รีเฟรชหน้าแล้ว Task หาย**

- เพราะข้อมูลเก็บในตัวแปร (RAM) พอรีเฟรชก็เคลียร์ทิ้ง
- _แก้โดย:_ เก็บลง `localStorage` หรือ Database

**6.3 วิธีทดสอบ Timer 30 นาที ให้เร็วขึ้น**

- แก้ code ตรง `duration` จาก `30 * 60` เป็น `5` (5 วินาที) เพื่อทดสอบ function จบงาน

---

## ส่วนที่ 7: Enhancement

**7.1 ฟังก์ชัน Reset Timer**

```javascript
function resetTimer(id) {
  const task = tasks.find((t) => t.id === id);
  clearInterval(task.intervalId);
  task.isRunning = false;
  task.timeLeft = task.duration; // คืนค่าเดิม
  renderTasks();
}
```

7.2 วิธีเก็บ LocalStorage

ใช้ localStorage.setItem('tasks', JSON.stringify(tasks)) ทุกครั้งที่มีการ เพิ่ม/ลบ/แก้ data

และตอนเปิดเว็บใช้ JSON.parse() ดึงกลับมา

7.3 ถ้าจะให้กำหนดเวลาเอง

แก้ HTML: เพิ่ม <input type="number" id="durationInput">

แก้ JS: ตอน addTask ให้อ่านค่าจาก input นี้มาคำนวณเป็นวินาที แทนที่จะใช้ค่าตายตัว 30 นาที

ส่วนที่ 8: Concepts เชิงลึก
8.1 renderTasks เรียกซ้ำบ่อยไปไหม

บ่อยไป (ทุก 1 วิ) ทำให้กินทรัพยากร browser ถ้า task เยอะๆ

วิธีแก้ (DRY/Performance): อัปเดตเฉพาะตัวเลขเวลาของ Task นั้นๆ ผ่าน DOM ID ไม่ต้อง re-render ทั้งก้อน

8.2 ใช้ requestAnimationFrame แทน setInterval

ดีกว่าในแง่ความลื่นไหลของ UI และหยุดทำงานเมื่อพับหน้าจอ (ประหยัดแบต) แต่เขียนยากกว่านิดหน่อยสำหรับการนับเวลาแบบวินาทีเป๊ะๆ

8.3 Memory Leak ใน setInterval

มีโอกาสเกิดขึ้นถ้าเรา deleteTask (ลบ task ออกจาก array/หน้าจอ) แต่ลืมสั่ง clearInterval ของ task นั้น ตัว timer จะยังทำงานอยู่ใน background กินแรมเครื่องไปเรื่อยๆ
