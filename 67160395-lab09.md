# ปฏิบัติการที่ 9: สร้าง App ง่ายๆ ด้วย Async/Await

## ส่วนที่ 1: การทำความเข้าใจโค้ด

**1.1 ความแตกต่างระหว่าง `duration` และ `timeLeft`**

- `duration`: คือเวลาตั้งต้น (30 นาที) เอาไว้ใช้ตอนจะ Reset หรือดูว่า Task นี้ยาวกี่นาที
- `timeLeft`: คือเวลาที่เหลืออยู่จริง ณ ตอนนั้น ซึ่งจะลดลงเรื่อยๆ
- _ถ้าไม่แยก:_ เราจะไม่รู้ว่า Task นี้เดิมทีตั้งเวลาไว้กี่นาที ถ้าจะเริ่มใหม่ก็ทำไม่ได้

**1.2 ความสำคัญของ `formatTime()`**

- แปลงตัวเลขวินาที (เช่น 90) ให้เป็นรูปแบบที่มนุษย์อ่านง่าย (01:30)
- _ถ้าไม่มี:_ user จะเห็นเลข 1800 วินาที ซึ่งดูยากมาก

**1.3 `setInterval()` vs `setTimeout()`**

- `setInterval`: ทำซ้ำไปเรื่อยๆ ตามเวลาที่กำหนด (Loop) จนกว่าจะสั่งหยุด
- `setTimeout`: ทำแค่ครั้งเดียว เมื่อครบเวลาที่กำหนด (Delay)

---

## ส่วนที่ 2: ฟังก์ชันการทำงาน

**2.1 ขั้นตอนเมื่อคลิกปุ่ม "▶️ เริ่ม"**

1.  ฟังก์ชัน `toggleTimer(id)` ถูกเรียก
2.  หา object task ที่ตรงกับ id
3.  เปลี่ยนสถานะ `isRunning = true`
4.  สั่ง `setInterval` เพื่อลด `timeLeft` ทุก 1 วินาที
5.  เรียก `renderTasks()` เพื่อเปลี่ยนปุ่มเป็น "หยุด"

**2.2 ทำไมต้อง `clearInterval()` ก่อน `isRunning = false`**

- ต้องหยุดกลไกการนับเวลา (System process) ก่อน แล้วค่อยอัปเดตสถานะข้อมูล เพื่อไม่ให้ Timer ทำงานซ้อนกันหรือทำงานค้างอยู่เบื้องหลัง

**2.3 ถ้าไม่มี `clearInterval()` ตอนหมดเวลา**

- เวลาจะติดลบไปเรื่อยๆ (-1, -2...) และเสียง Alarm อาจจะดังไม่หยุด หรือ Logic การจบงานจะไม่ทำงาน

---

## ส่วนที่ 3: DOM และ UI

**3.1 การแยกฟังก์ชัน `renderTasks()`**

- แยกได้เป็น: `createTaskHTML(task)` สำหรับสร้างโค้ด HTML ของแต่ละก้อน และ `updateTaskList()` สำหรับเอา HTML ไปใส่ใน Container

**3.2 วิธีอัปเดต UI**

- ตอนนี้ใช้: ลบแล้วสร้างใหม่หมด (`innerHTML`)
- วิธีอื่นที่ดีกว่า: เลือก Element ที่เจาะจง (เช่น `span` ของเวลา) แล้วแก้แค่ `textContent` โดยไม่ต้อง Render ใหม่ทั้งลิสต์

**3.3 ความสำคัญของ "keypress"**

- ทำให้กดปุ่ม Enter ที่คีย์บอร์ดเพื่อเพิ่ม Task ได้เลย
- _ถ้าลบออก:_ ต้องเลื่อนเมาส์ไปกดปุ่ม "เพิ่ม" เท่านั้น ไม่สะดวก

---

## ส่วนที่ 4: Web Audio API

**4.1 อธิบายการตั้งค่าเสียง**

- `frequency = 800`: ความถี่เสียง (โทนเสียงสูง/แหลม)
- `type = "sine"`: รูปแบบคลื่นเสียง (Sine wave เสียงจะนุ่มๆ ไม่แตก)
- `gain = 0.3`: ความดังเสียง (30%)

**4.2 ทำไม Alarm แค่ 0.5 วิ**

- เพื่อให้แค่ "แจ้งเตือน" ว่าเสร็จแล้ว ไม่ให้รบกวนจนน่ารำคาญ
- _ถ้า 2 วิ:_ ผู้ใช้อาจจะตกใจหรือรำคาญ เพราะเสียง beep ยาวเกินไป

---

## ส่วนที่ 5: Array Methods

**5.1 การใช้ `filter()` ใน `deleteTask`**

- ใช้สร้าง Array ใหม่ที่ **ไม่มี** ID ที่เราเลือก (คัดตัวที่จะลบออกไป)
- _วิธีอื่น:_ ใช้ `splice()` แต่ต้องหา index ก่อน หรือใช้ `for loop` สร้าง array ใหม่เอง

**5.2 การใช้ `map()` ใน `renderTasks`**

- ใช้แปลงข้อมูล (Object) ให้กลายเป็น HTML String
- _ใช้ `forEach` ได้ไหม:_ ไม่ดี เพราะ `forEach` ไม่ return ค่ากลับมา ต้องสร้างตัวแปรมารอรับค่าเพิ่มเอง ทำให้โค้ดยาวขึ้น

---

## ส่วนที่ 6: ข้อบกพร่องและการแก้ไข

**6.1 ถ้ากดเริ่ม 2 Task พร้อมกัน**

- ทำงานได้ปกติ เพราะแยก `intervalId` เก็บไว้ใน object ของใครของมัน ไม่ตีกัน

**6.2 รีเฟรชหน้าแล้ว Task หาย**

- เพราะข้อมูลเก็บในตัวแปร (RAM) พอรีเฟรชก็เคลียร์ทิ้ง
- _แก้โดย:_ เก็บลง `localStorage` หรือ Database

**6.3 วิธีทดสอบ Timer 30 นาที ให้เร็วขึ้น**

- แก้ code ตรง `duration` จาก `30 * 60` เป็น `5` (5 วินาที) เพื่อทดสอบ function จบงาน

---

## ส่วนที่ 7: Enhancement

**7.1 ฟังก์ชัน Reset Timer**

```javascript
function resetTimer(id) {
  const task = tasks.find((t) => t.id === id);
  clearInterval(task.intervalId);
  task.isRunning = false;
  task.timeLeft = task.duration; // คืนค่าเดิม
  renderTasks();
}
```

7.2 วิธีเก็บ LocalStorage

ใช้ localStorage.setItem('tasks', JSON.stringify(tasks)) ทุกครั้งที่มีการ เพิ่ม/ลบ/แก้ data

และตอนเปิดเว็บใช้ JSON.parse() ดึงกลับมา

7.3 ถ้าจะให้กำหนดเวลาเอง

แก้ HTML: เพิ่ม <input type="number" id="durationInput">

แก้ JS: ตอน addTask ให้อ่านค่าจาก input นี้มาคำนวณเป็นวินาที แทนที่จะใช้ค่าตายตัว 30 นาที

ส่วนที่ 8: Concepts เชิงลึก
8.1 renderTasks เรียกซ้ำบ่อยไปไหม

บ่อยไป (ทุก 1 วิ) ทำให้กินทรัพยากร browser ถ้า task เยอะๆ

วิธีแก้ (DRY/Performance): อัปเดตเฉพาะตัวเลขเวลาของ Task นั้นๆ ผ่าน DOM ID ไม่ต้อง re-render ทั้งก้อน

8.2 ใช้ requestAnimationFrame แทน setInterval

ดีกว่าในแง่ความลื่นไหลของ UI และหยุดทำงานเมื่อพับหน้าจอ (ประหยัดแบต) แต่เขียนยากกว่านิดหน่อยสำหรับการนับเวลาแบบวินาทีเป๊ะๆ

8.3 Memory Leak ใน setInterval

## มีโอกาสเกิดขึ้นถ้าเรา deleteTask (ลบ task ออกจาก array/หน้าจอ) แต่ลืมสั่ง clearInterval ของ task นั้น ตัว timer จะยังทำงานอยู่ใน background กินแรมเครื่องไปเรื่อยๆ

# ปฏิบัติการที่ 9: Pomodoro Timer App

## ส่วนที่ 1: ความเข้าใจเทคนิค Pomodoro

**1.1 เทคนิค Pomodoro คืออะไร**

- **คือ:** เทคนิคการบริหารเวลาโดยแบ่งการทำงานเป็นช่วงๆ (Focus) ปกติ 25 นาที สลับกับการพักสั้นๆ (Break) 5 นาที
- **เหตุผล:** เพื่อช่วยรักษาความสดชื่นของสมอง ลดความเหนื่อยล้า (Burnout) และเพิ่มประสิทธิภาพในการโฟกัส

**1.2 หากต้องการปรับเวลา Work/Break**

- **ผู้ใช้งาน:** ปรับได้ที่หน้า UI ในส่วน `<div class="settings">` ผ่านช่อง Input `#workTime` และ `#breakTime`
- **นักพัฒนา:** แก้ไขค่าเริ่มต้นในตัวแปร `state` หรือใน HTML attribute `value="25"` ของ input

**1.3 ทำไมต้องมี Long Break (15 นาที)**

- เพื่อให้สมองได้พักฟื้นเต็มที่หลังจากทำงานหนักต่อเนื่องครบ 4 รอบ (Pomodoros) เป็นการ Reset สมองก่อนเริ่มรอบใหญ่ถัดไป

---

## ส่วนที่ 2: การจัดโครงสร้าง State

**2.1 State ที่จำเป็น**

- `timeLeft` (วินาทีที่เหลือ)
- `isWorkPhase` (บอกว่าเป็นช่วงงานหรือพัก)
- `currentSession` (ตัวนับจำนวนรอบ 1-4)
- `isRunning` (สถานะว่าเวลากำลังเดินอยู่หรือไม่)

**2.2 ทำไมต้องมี `currentSession`**

- เพราะ Logic การพักยาว (Long Break) ขึ้นอยู่กับจำนวนรอบ เราต้องรู้ว่าตอนนี้อยู่รอบที่เท่าไหร่ (เช่น `if (currentSession % 4 === 0)`) ลำพังแค่รู้ว่า Work/Break ไม่พอ

**2.3 การอัปเดต Pomodoro Count**

- ใน JS เมื่อจบ Work Phase (`timeLeft <= 0`) ให้เพิ่มค่าตัวแปร `completedSessions++`
- จากนั้นอัปเดต DOM ID `#completedCount` ด้วยค่าใหม่

---

## ส่วนที่ 3: Timer Logic

**3.1 การทำงานของ `setInterval`**

- ทุกๆ 1,000 ms (1 วินาที) ฟังก์ชันจะทำงาน 1 ครั้ง เพื่อลดค่า `timeLeft` ลง 1 และตรวจสอบว่าเวลาหมดหรือยัง (`<= 0`)

**3.2 ความสำคัญของ `state.intervalId`**

- เป็นตัวแปรที่เก็บ "ID ของ Loop" เอาไว้ เพื่อใช้กับคำสั่ง `clearInterval(state.intervalId)`
- **ถ้าไม่มี:** เราจะสั่งหยุดเวลา (Pause) หรือรีเซ็ตไม่ได้เลย Loop จะทำงานตลอดไป

**3.3 ถ้าคลิก "เริ่ม" 2 ครั้ง**

- ระบบออกแบบไว้เป็นปุ่ม Toggle:
  - คลิกครั้งแรก (`isRunning = false`) -> สั่ง Start
  - คลิกครั้งที่สอง (`isRunning = true`) -> สั่ง Pause
- ดังนั้นมันจะไม่บั๊ก แต่จะทำงานเป็นการ **เริ่ม** และ **หยุด** สลับกัน

---

## ส่วนที่ 4: DOM & UI

**4.1 ฟังก์ชัน `updateDisplay()`**

- **ทำหน้าที่:** ซิงค์ข้อมูลจาก JS State ไปสู่หน้าจอ HTML
  - อัปเดตตัวเลขเวลา (`#timeDisplay`)
  - ปรับความกว้างกราฟ (`#progressBar`)
  - เปลี่ยนข้อความและสีของ Phase (`.phase.work` / `.phase.break`)
- **เรียกใช้เมื่อ:** โหลดหน้าเว็บ, เวลาเดินทุกวินาที, กดปุ่มเริ่ม/หยุด/รีเซ็ต

**4.2 ความสำคัญของ `formatTime` (padding)**

- ใช้ `padStart(2, "0")` เพื่อให้เวลาแสดงเป็น 2 หลักเสมอ (เช่น `05:03` แทน `5:3`) เพื่อความสวยงามและอ่านง่ายคงที่

**4.3 การคำนวณ Progress Bar**

- **สูตร:** `((เวลาทั้งหมด - เวลาที่เหลือ) / เวลาทั้งหมด) * 100`
- **CSS:** ค่าที่ได้จะถูกนำไปใส่ใน `style.width` ของ `#progressBar` และใน CSS มี `transition: width 0.3s ease` ช่วยให้หลอดขยับนุ่มนวล

---

## ส่วนที่ 5: Events & Controls

**5.1 ปุ่มควบคุม**

- **Start (`#startBtn`):** เรียก `startTimer()` (สลับเริ่ม/หยุด)
- **Reset (`#resetBtn`):** เรียก `resetTimer()` (คืนค่าเริ่มต้น)
- **Inputs (`#workTime`, `#breakTime`):** มี Event `change` เพื่ออัปเดตระยะเวลาทันทีที่แก้ไข

**5.2 ทำไม Pause ต้อง `clearInterval`**

- การแค่เปลี่ยนตัวแปร `isRunning = false` ไม่เพียงพอ ต้องสั่ง CPU ให้หยุด Loop การทำงานด้วย `clearInterval` เพื่อไม่ให้กินทรัพยากรเครื่อง

**5.3 การตั้งค่า Reset**

- `timeLeft` = กลับไปเท่ากับ `workDuration`
- `isWorkPhase` = `true`
- `currentSession` = 1
- `progressBar` width = 0%

---

## ส่วนที่ 6: Notifications & Sound

**6.1 เทคนิคสร้างเสียง**

- ใช้ **Web Audio API** (`AudioContext`) ซึ่งเป็นการสร้างคลื่นเสียง (Oscillator) ขึ้นมาสดๆ ผ่าน Code ไม่ต้องโหลดไฟล์ .mp3 ทำให้เบาและรวดเร็ว

**6.2 ความแตกต่าง Work/Break**

- **เสียง:** ใช้ความถี่ต่างกัน (เช่น 800Hz สำหรับ Work, 1200Hz สำหรับ Break) เพื่อให้แยกแยะได้ด้วยการฟัง
- **สี:** CSS เปลี่ยนสี `.timer-display` (แดง/เขียว) เพื่อแยกแยะด้วยการมอง

**6.3 Desktop Notification**

- ใช้ Browser API: `new Notification("Work Finished!")`
- **ข้อควรระวัง:** ต้องขออนุญาตผู้ใช้ก่อนด้วย `Notification.requestPermission()`

---

## ส่วนที่ 7: Progress Tracking & Stats

**7.1 ข้อมูลที่ต้องติดตาม**

- จำนวน Pomodoro ที่สำเร็จ (`completedSessions`)
- เวลารวมที่ใช้ไป (`Total Time`)

**7.2 ตำแหน่งอัปเดต Stats**

- ดีที่สุดคือทำตอน **"จบ Work Phase"** (ในเงื่อนไข `timeLeft <= 0`)

**7.3 การเก็บข้อมูล (Persistence)**

- ใช้ `localStorage`:
  - บันทึก: `localStorage.setItem('pomoStats', JSON.stringify(statsObj))`
  - อ่าน: `JSON.parse(localStorage.getItem('pomoStats'))` ตอนโหลดหน้าเว็บ

---

## ส่วนที่ 8: Bug Detection

**8.1 เปิด DevTools**

- `setInterval` ยังทำงานต่อ แต่อาจมีความคลาดเคลื่อนเล็กน้อยหาก Browser ลดความสำคัญของ Tab นั้นลง (Throttling)

**8.2 Memory Leak**

- เกิดขึ้นได้ถ้าเราสร้าง Event Listener ซ้ำๆ ทุกครั้งที่กดปุ่ม Start โดยไม่ลบของเก่า
- _วิธีแก้:_ แยก Event Listener ไว้นอกฟังก์ชัน `startTimer` (ประกาศครั้งเดียวตอนเริ่ม)

**8.3 Mobile Lock Screen (สำคัญ)**

- **ปัญหา:** มือถือมักจะหยุด JS เมื่อปิดหน้าจอ ทำให้เวลานับช้ากว่าความจริง
- **วิธีแก้:** อย่าพึ่งแค่การนับลบทีละ 1 แต่ให้บันทึก **Timestamp ของเวลาจบ (Target Time)** แล้วคำนวณหาผลต่างกับเวลาปัจจุบัน (`Target - Now`)

---

## ส่วนที่ 9: Architecture & Code Quality

**9.1 แยก Logic ออกจาก UI**

- สร้าง Class: `class TimerEngine { ... }` รับผิดชอบแค่เรื่องเวลาและการคำนวณ ไม่ยุ่งกับ DOM โดยตรง แล้วให้ UI เรียกใช้ Method เอา

**9.2 การใช้ Object**

- รวมตัวแปรทั้งหมดไว้ใน `const state = { ... }` ช่วยให้โค้ดเป็นระเบียบ และส่งค่าไปมาระหว่างฟังก์ชันได้ง่าย

**9.3 Reusability**

- ฟังก์ชัน `formatTime(seconds)` เป็น Utility Function ที่ดี สามารถนำไปใช้กับโปรเจกต์อื่นได้ทันที

---

## ส่วนที่ 10: Enhancements

**10.1 Dark Mode**

- **CSS:** เพิ่ม Class `body.dark-mode` เปลี่ยนสีพื้นหลังและตัวอักษร
- **JS:** ผูกปุ่ม Toggle กับ `document.body.classList.toggle('dark-mode')`

**10.2 Session History**

- สร้าง Array เก็บประวัติ: `historyLogs = [{ type: 'WORK', time: '10:00 AM' }, ...]`

**10.3 Keyboard Shortcuts**

- ใช้ Event `keydown` บน `document`:
  - `Spacebar` -> สั่งคลิกปุ่ม Start
  - `R` -> สั่งคลิกปุ่ม Reset
